---
title: 自己动手写一个通信协议
categories:
  - 开发日记
abbrlink: d667380c
date: 2022-03-17 08:56:44
tags:
 - C#
 - 通信
cover: 1.jpg
---

虽说轮子很多，但是还是想自己练练手。

# 什么是通信协议
我们常用的聊天软件比如：微信，都是基于一组通信协议进行服务端与客户端数据交互。协议指的就是客户端与服务端事先约定好的，每个二进制数据包中，每一段字节分别代表什么含义的规则。如下图所示一个简单的登录指令：

```
指令   用户名     分隔符   密码
 1   f i a s h   \0      p w d
```
在这个数据包中，第一个字节为 1 表示这是一个登录指令，接下来是用户名和密码，这两个值以 \0 分割，客户端发送这段二进制数据包到服务端，服务端就能根据这个协议来取出用户名密码，进行登录逻辑。实际的通信协议设计中，我们会考虑更多细节，要比这个稍微复杂一些。
# 通信协议的设计

|字段|占位|用途|
|:-:|:-:|:-:|
|1|4|数魔（0x12345678）|
|2|1|版本号|
|3|1|序列化算法|
|4|1|指令|
|5|4|数据长度|
|6|N|数据|
|7|4|数魔（0x87654321）|

1. 第一个字段为魔数（magic_number），通常情况下都是几个字节（这里我们定义 4 个字节），魔数的作用类似于协议内的标识，通过客户端与服务端魔数对比，我们就知道这组二进制数据是否属于当前通信协议。这和 Java 字节码 中的魔数 0xCAFEBABE 用来标识这个文件，有着异曲同工之妙。
2. 第二个字段为版本号，占用 1 个字节，通常情况下是预留字段。
3. 第三部分是序列化算法，占用 1 个字节，表示如何把 Java 对象转换成二进制，二进制转换成C#对象,比如C#自带的序列化，json，hessian等序列化方式。
4. 第四部分是指令，占用 1 个字节，服务端或者客户端每收到一种指令都会有相应的处理逻辑，最高支持256种指令，对于我们这个通信系统来说已经完全足够了。
5. 第五部分是数据长度，占用 4 个字节。
6. 最后一部分则是数据内容，每一个指令对应的数据是不一样的，比如登录的时候需要用户名密码，收消息的时候需要用户标识和具体消息内容等等。

通常情况下，这样一套标准的协议能够适配大多数情况下的服务端与客户端的通信场景，接下来我们就来看一下我们如何实现这套协议。

# 通信协议的实现

我们把 C# 对象封装成二进制的过程叫编码， 从二进制数据包解析成 C# 对象的过程叫解码，我们先来定义一下客户端与服务端通信的 C# 对象。

``` csharp
public abstract class Packet
{
    /// <summary>
    /// 协议版本
    /// </summary>
    public readonly byte verion = 1;
    public abstract byte getCommand();
}
```

接下来，我们拿客户端登录请求为例，定义登录请求数据包。

``` csharp
public static class CommandID{
    public static byte LOGIN_REQUEST = 0;
}

public class LoginPack : Packet
{
    private string userName ;
    private int userId;
    private string password;
    public override byte getCommand()
    {
        return CommandID.LOGIN_REQUEST;
    }
}
```

CommandID 定义一些指令，不同的 CommandID 指令分别对应不同的数据内容。
这里 Command 定义了 LOGIN_REQUEST 指令表示登录请求，相应的就会有与之对应的 C# 对象 `LoginRequestPacket`。

C# 对象定义完成之后，接下来我们就需要定义一种规则，如何把一个 C# 对象转换成二进制数据，这个规则叫做 C# 对象的序列化。

# 序列化

``` csharp
public abstract class Serializer
    {
        /// <summary>
        /// 序列化算法
        /// </summary>
        /// <returns></returns>
        public abstract byte getSerializerAlgorithm();
        /// <summary>
        /// 对象转为二进制
        /// </summary>
        /// <returns></returns>
        public abstract byte[] serialize(object obj);
        /// <summary>
        /// 二进制转对象
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public abstract T deserialize<T>(byte[] bytes);
    }
```

1. getSerializerAlgorithm() 获取具体的序列化算法标识。
2. serialize() 将 C# 对象转换成字节数组。
3. deserialize() 将字节数组转换成某种类型的 C# 对象。

序列化接口的实现，这里我们使用最简单的 json 序列化方式，使用`System.Web.Script.Serialization`

```csharp
    public class SerializerAlgorithm
    {
        /**
         * json 序列化标识
         */
        public static  byte JSON = 1;
    }
    public class JSONSerializer : Serializer
    {
        JavaScriptSerializer js = new JavaScriptSerializer();
        public override byte getSerializerAlgorithm()
        {
            return SerializerAlgorithm.JSON;
        }

        public override byte[] serialize(object obj)
        {
            return Encoding.UTF8.GetBytes(js.Serialize(obj));
        }

        public override T deserialize<T>(byte[] bytes)
        {
            return js.Deserialize<T>(Encoding.UTF8.GetString(bytes));
        }
    }
```

这样我们就实现了序列化的相关逻辑。

序列化定义了C# 对象与二进制数据的互转过程，接下来，我们就来学习一下，如何把这部分的数据编码到通信协议的二进制数据包中去。

# 编码＆解码

烂尾...

