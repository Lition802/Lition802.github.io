---
title: ESP8266使用旋转编码器（二）
tags: ESP8266
abbrlink: 11071
date: 2024-02-03 17:03:08
---

写完第一版的程序之后我发现按下按钮只能触发一次，按下之后电平就被拉低了，一直为LOW。

[![pFQvOUJ.md.png](https://s11.ax1x.com/2024/02/03/pFQvOUJ.md.png)](https://imgse.com/i/pFQvOUJ)

按照上面的方法接入一个电阻之后，电平为LOW的时候用3v电压把电平拉回来。

同时我还接入了OLED显示屏显示旋转的值。

[![pFQvvCR.md.jpg](https://s11.ax1x.com/2024/02/03/pFQvvCR.md.jpg)](https://imgse.com/i/pFQvvCR)

|开发板引脚|元件引脚|
|:-:|:-:|
|D0|编码器SW|
|D0|下拉电阻|
|D1|屏幕SCL|
|D2|屏幕SDA|
|D5|编码器CLK|
|D6|编码器DT|

这里把D3和D4空出来因为下拉这两个引脚会导致无法上传程序

```c
// Rotary Encoder Inputs
#define CLK D5
#define DT D6
#define SW D0

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128  // OLED display width, in pixels
#define SCREEN_HEIGHT 32  // OLED display height, in pixels

// Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
Adafruit_SSD1306 display(128, 64, &Wire, -1);


int counter = 0;
int currentStateCLK;
int lastStateCLK;
String currentDir = "";

unsigned long lastButtonPress = 0;

void ShowText(String text) {
  display.clearDisplay();
  display.setTextSize(1);  // Draw 2X-scale text 2倍字体
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(1, 1);  //显示的坐标位置
  display.println(text);
  display.display();  // Show text
}


void ShowNum(int num) {
  display.clearDisplay();
  display.setTextSize(2);  // Draw 2X-scale text 2倍字体
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(10, 10);  //显示的坐标位置
  display.println(num);
  display.display();  // Show text
}


void setup() {

  // Set encoder pins as inputs
  pinMode(CLK, INPUT);
  pinMode(DT, INPUT);
  pinMode(SW, INPUT_PULLUP);

  // Setup Serial Monitor
  Serial.begin(115200);

  // Read the initial state of CLK
  lastStateCLK = digitalRead(CLK);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {  // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;  // Don't proceed, loop forever
  }
  Serial.println(".");
  Serial.println(".");
  Serial.println("boot up complete");
  // 清空显示
  ShowText("standby....");
}

void loop() {

  // Read the current state of CLK
  currentStateCLK = digitalRead(CLK);

  // If last and current state of CLK are different, then pulse occurred
  // React to only 1 state change to avoid double count
  if (currentStateCLK != lastStateCLK && currentStateCLK == 1) {

    // If the DT state is different than the CLK state then
    // the encoder is rotating CCW so decrement
    if (digitalRead(DT) != currentStateCLK) {
      counter--;
      currentDir = "CCW";
    } else {
      // Encoder is rotating CW so increment
      counter++;
      currentDir = "CW";
    }

    Serial.print("Direction: ");
    Serial.print(currentDir);
    Serial.print(" | Counter: ");
    Serial.println(counter);
    ShowNum(counter);
    // 清空显示
    // display.clearDisplay();
    // // 使更改的显示生效
    display.display();
  }

  // Remember last CLK state
  lastStateCLK = currentStateCLK;

  // Read the button state
  int btnState = digitalRead(SW);
  // Serial.println(btnState);
  //If we detect LOW signal, button is pressed
  if (btnState == LOW) {
    //if 50ms have passed since last LOW pulse, it means that the
    //button has been pressed, released and pressed again
    if (millis() - lastButtonPress > 50) {
      Serial.println("Button pressed!");
      counter = 0;
      ShowNum(counter);
      display.display();
    }

    // Remember last button press event
    lastButtonPress = millis();
  }

  // Put in a slight delay to help debounce the reading
  delay(1);
}

```